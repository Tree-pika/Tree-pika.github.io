<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="中断笔记   计算机的 performance 受 inst#（ISA和编译器决定）, clock cycle time 和 clock cycles per inst (CPI) 决定。Clock cycle time 和 CPI 受 processor（CPU hardware） 的实现方式影响。本章介绍 RISC-V 的 processor 一种实现。  1、单周期 processor">
<meta property="og:type" content="article">
<meta property="og:title" content="ch4:processor">
<meta property="og:url" content="http://example.com/2025/10/24/ch4-processor/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="中断笔记   计算机的 performance 受 inst#（ISA和编译器决定）, clock cycle time 和 clock cycles per inst (CPI) 决定。Clock cycle time 和 CPI 受 processor（CPU hardware） 的实现方式影响。本章介绍 RISC-V 的 processor 一种实现。  1、单周期 processor">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731500271198-c1c63d98-79a2-4be1-a12c-84119428dcec.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730857560601-daf17c1b-97f8-4b27-b301-d58862f2f417.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731486875379-2d014166-e3a0-450a-8400-9859849922e5.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731489122153-fac4136e-7a6b-4552-89a9-e7f0169ca40b.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731499137854-a93463c6-d4b2-4a1e-88a7-9f064a6be1be.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/42470693/1733751112198-19ecc247-84b2-413b-a573-80101800a99a.jpeg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731826738539-4e6d8356-46e4-43ae-8939-abc0145cd3df.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730858436685-0700246f-6265-411f-9e76-7c1c3d37312d.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730883750189-7210b0af-b2cf-43c5-bcab-184ff1473a48.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730892121123-db460252-bc3d-4469-b450-4462fd5fde68.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730896659350-7a5f38a2-34cd-4baa-98b4-4d63d329e16a.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730896627383-6b3ed972-7615-411b-8e03-9442a6caaeb1.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730895457420-35d37488-a72b-40e9-ac29-0705d1da4c25.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730896377430-73d458e9-624c-4c40-b502-e8eb9e1dbab8.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730897148986-b31558d3-51a4-4c65-8aa0-6ad58da6590a.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730897507458-c43526d1-45e3-47f2-8e48-74e158356231.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730897882150-735aef5c-5415-417f-8d04-d417359bad5a.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730898847671-399d9089-3b7f-459b-93cc-7c6b2aa4c1d1.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730898990310-6e1627ab-5eed-4d36-a61e-1d16e07e3618.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730899444434-e05a8089-9ae8-4c01-95e2-6ef676eb12ca.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731419365170-9ed66d02-aa22-4b19-b7ec-c687a611a6c6.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731419796622-9f8e7ff3-148e-47d0-ab73-e44efce39486.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731420011622-7410418b-8ca5-4210-83b5-94fd9e4d57f8.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731420828968-47404764-1c61-4823-a335-f528e3808284.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731422908269-26e88199-65dc-4ba9-ae93-7fee9b8320fb.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731423684109-234c91a2-5d55-4edc-a929-22df173ee418.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731424465577-79600989-5c8a-4e90-8596-ed676d7fe8bd.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731425133804-ec14f805-5e1a-4408-b033-0ad36e7f519d.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731463738111-78eb2fde-058b-4012-a2de-f34d13fb1496.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731425290031-aa1ba196-1bc7-4f8c-a8ac-6240c66dc80f.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731425322337-07cf057a-c8c0-4875-b65f-a34386884c29.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731464218820-74f95d5a-e5dc-48d1-932b-fbdd039b31f8.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1733185308947-001908ec-7684-43ba-aac0-e6b8e8eecdf0.png">
<meta property="article:published_time" content="2025-10-24T06:40:00.000Z">
<meta property="article:modified_time" content="2025-10-24T08:57:13.327Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="processor">
<meta property="article:tag" content="计算机组成">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731500271198-c1c63d98-79a2-4be1-a12c-84119428dcec.png">


<link rel="canonical" href="http://example.com/2025/10/24/ch4-processor/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2025/10/24/ch4-processor/","path":"2025/10/24/ch4-processor/","title":"ch4:processor"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ch4:processor | Hexo</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#pXGmP"><span class="nav-number">1.</span> <span class="nav-text">1、单周期 processor</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ancdz"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 overview--datapath &amp; controller</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JtkB0"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nN0rn"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2 关于指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#U7blf"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 R型指令--datapath</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PTuq1"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 Load指令和Store指令--datapath</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mxC3m"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 branch #inst--datapath</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FNWRn"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 datapath 整合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ss5UC"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 controller</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#o79R8"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1 overview  &amp;（main）Control一级译码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GFWvp"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2  **ALU control** 二级译码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#QvAV0"><span class="nav-number">2.</span> <span class="nav-text">2、Pipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#r1tlf"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#M3MBu"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 Structure hazards</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HPwY0"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 Data hazards</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BNDS4"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 解决问题的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#E8QPv"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 实现解决方法_**Forwarding&#x2F;bypass——**__**设计datapath**_</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QtaGN"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3 datapath with Forwarding（将controller加上）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mp5a0"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.3.4 遇到 load 指令不得不 stall</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WugLZ"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 Control&#x2F;Branch hazards</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DHu0Z"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 Instruction-Level Parallelism (ILP)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Eu4ub"><span class="nav-number">3.</span> <span class="nav-text">3、Interrupts &amp; Exceptions </span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#KQUdm"><span class="nav-number">3.1.</span> <span class="nav-text">3.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cLzoZ"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 M-mode</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/24/ch4-processor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="ch4:processor | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ch4:processor
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-10-24 14:40:00 / Modified: 16:57:13" itemprop="dateCreated datePublished" datetime="2025-10-24T14:40:00+08:00">2025-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">专业课笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><ul>
<li><input disabled="" type="checkbox"> 中断笔记</li>
</ul>
<blockquote>
<p><font style="color:rgba(0, 0, 0, 0.87);">计算机的 performance 受 </font><strong><font style="color:rgba(0, 0, 0, 0.87);">inst#（ISA和编译器决定）, clock cycle time 和 clock cycles per inst (CPI)</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> 决定。Clock cycle time 和 CPI 受 processor（CPU hardware） 的实现方式影响。本章介绍 RISC-V 的 processor 一种实现。</font></p>
</blockquote>
<h1 id="pXGmP">1、单周期 processor</h1>
> 单周期CPU：一个周期内完成一条指令的所有事情；CPI = 1
>
> + datapath：数据流通的部件；每个部件在一个周期内只能完成一个功能；#inst和data的memory需要分开
> + controller：控制数据流通——使用MUX
> + ISA 影响datapath/controller设计
>
> 需要实现的操作：
>
> + 内存访问：ld，sd
> + 算术/逻辑操作：add，sub，and，or
> + control transfer：beq
>
> 不同的指令前两步是一样的：IF/ID
>
> 后面depend on #inst class：
>
> + Use ALU 计算算术结果/内存访问所需的地址/branch comparison
> + Access data memory for ld/sd
> + target address/PC+4-->PC
> + write result to reg：R型写ALU results，I型写memory data
>

<h2 id="ancdz">1.1 overview--datapath & controller</h2>
<h3 id="JtkB0">1.1.1</h3>
> 寄存器是由D触发器搭建
>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731500271198-c1c63d98-79a2-4be1-a12c-84119428dcec.png"></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">上图展示了一个 RISC-V 核心指令的实现（</font><strong><font style="color:rgba(0, 0, 0, 0.87);">datapath with control</font></strong><font style="color:rgba(0, 0, 0, 0.87);">），包括 </font><code>ld</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>sd</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>add</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>sub</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>and</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>or</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>beq</code></li>
<li>包含的模块有：<strong><font style="color:rgba(0, 0, 0, 0.87);">PC</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> </font><strong><font style="color:rgba(0, 0, 0, 0.87);">（program counter）64位</font></strong><font style="color:rgba(0, 0, 0, 0.87);">寄存器、 </font><strong><font style="color:rgba(0, 0, 0, 0.87);">Instruction memory（左边）、Control</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> （中间蓝色部分）、</font><strong><font style="color:rgba(0, 0, 0, 0.87);">Registers file寄存器组</font></strong><font style="color:rgba(0, 0, 0, 0.87);">（32个寄存器，x0-x31，中间黑色）、</font><strong><font style="color:rgba(0, 0, 0, 0.87);">ALU</font></strong><font style="color:rgba(0, 0, 0, 0.87);">、</font><strong><font style="color:rgba(0, 0, 0, 0.87);">Data memory(右边)</font></strong><font style="color:rgba(0, 0, 0, 0.87);">、</font><strong><font style="color:rgba(0, 0, 0, 0.87);">adder、MUX！</font></strong></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">PC </font><strong><font style="color:rgba(0, 0, 0, 0.87);">寄存器</font></strong><font style="color:rgba(0, 0, 0, 0.87);">存储当前运行到的指令的地址。</font><strong><font style="color:rgba(0, 0, 0, 0.87);">PC</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> 寄存器连到 </font><strong><font style="color:rgba(0, 0, 0, 0.87);">Instruction memory</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> 中，读出的结果就是当前要运行的指令。从取出来rs1&#x2F;rs2&#x2F;rd给regs file；opcode给</font><strong><font style="color:rgba(0, 0, 0, 0.87);">Control</font></strong><font style="color:rgba(0, 0, 0, 0.87);">；immediate给ALU</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">这个指令被 </font><strong><font style="color:rgba(0, 0, 0, 0.87);">Control</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> 解析产生相应的信号，控制数据流动。我们在 </font><strong><font style="color:rgba(0, 0, 0, 0.87);">1.6 </font></strong><font style="color:rgba(0, 0, 0, 0.87);">小节中具体说明它的实现。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">PS：</font><em><font style="color:rgba(0, 0, 0, 0.87);">所有的模块都会产生output</font></em><font style="color:rgba(0, 0, 0, 0.87);">，（即使在运行某特定指令时未用到），但是有些output are not used</font></li>
</ul>
<h3 id="nN0rn">1.1.2 关于指令</h3>
指令执行包括以下五个阶段：

<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.87);">Fetch</font></strong><font style="color:rgba(0, 0, 0, 0.87);">:</font><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">Take instructions from the instruction memory</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">Modify PC to point the </font><strong><font style="color:rgba(0, 0, 0, 0.87);">next</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> instruction（PC+4&#x2F;target address）</font></li>
</ul>
</li>
<li><strong><font style="color:rgba(0, 0, 0, 0.87);">Instruction decoding &amp; Read Operand</font></strong><font style="color:rgba(0, 0, 0, 0.87);">:</font><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">Will be translated into machine control command</font></li>
</ul>
</li>
</ul>
<p>将指令解码为对应的32位机器码</p>
<pre><code>- &lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;Reading Register Operands, whether or not to use&lt;/font&gt;
</code></pre>
<p>都按照R型指令的格式，来分配机器码的哪些位去到rs1&#x2F;rs2&#x2F;rd&#x2F;opcode</p>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.87);">Executive Control</font></strong><font style="color:rgba(0, 0, 0, 0.87);">:</font><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">Control the implementation of the corresponding </font><strong><font style="color:rgba(0, 0, 0, 0.87);">ALU</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> operation</font></li>
</ul>
</li>
</ul>
<p>现在已经知道对应的opcode——有些是寄存器之间的运算，有些是寄存器和immediate计算</p>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.87);">Memory access</font></strong><font style="color:rgba(0, 0, 0, 0.87);">:</font><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">Write or Read data from memory</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">Only ld&#x2F;sd</font></li>
</ul>
</li>
<li><strong><font style="color:rgba(0, 0, 0, 0.87);">Write results to register</font></strong><font style="color:rgba(0, 0, 0, 0.87);">:</font><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">If it is R-type instructions, ALU results are written to rd</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">If it is I-type instructions（load）, memory data are written to rd</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">branch inst不需要这步</font></li>
</ul>
</li>
<li><strong><font style="color:rgba(0, 0, 0, 0.87);">Modify PC for branch instructions</font></strong></li>
</ul>
<h2 id="U7blf">1.2 R型指令--datapath</h2>
+ `add`<font style="color:rgba(0, 0, 0, 0.87);"> , </font>`sub`<font style="color:rgba(0, 0, 0, 0.87);"> , </font>`and`<font style="color:rgba(0, 0, 0, 0.87);"> , </font>`or`<font style="color:rgba(0, 0, 0, 0.87);"> 这几个 R 型指令总共需要访问 3 个寄存器，如下图所示：</font>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730857560601-daf17c1b-97f8-4b27-b301-d58862f2f417.png"></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">(1) 处取出指令， </font><ul>
<li><code>inst[6:0]</code><font style="color:rgba(0, 0, 0, 0.87);"> 被送到 Control 产生对应的控制信号，我们稍后可以看到； </font></li>
<li><code>inst[19:15]</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>[24:20]</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>[11:7]</code><font style="color:rgba(0, 0, 0, 0.87);"> 分别对应 </font><code>rs1/read reg1</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>rs2/read reg2</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>rd/write reg</code><font style="color:rgba(0, 0, 0, 0.87);"> ，</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">被连入 </font><strong><font style="color:rgba(0, 0, 0, 0.87);">Registers</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> 这个结构，对应的输出 </font><code>Read data 1</code><font style="color:rgba(0, 0, 0, 0.87);"> 和 </font><code>Read data 2</code><font style="color:rgba(0, 0, 0, 0.87);"> 两处的值即变为 </font><code>rs1</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>rs2</code><font style="color:rgba(0, 0, 0, 0.87);"> 的值；</font></li>
</ul>
</li>
<li><font style="color:rgba(0, 0, 0, 0.87);">(2) 处 </font><strong><font style="color:rgba(0, 0, 0, 0.87);">MUX</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> </font><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">在 </font><code>ALUSrc = 0</code><font style="color:rgba(0, 0, 0, 0.87);"> 的信号作用下选择 </font><code>Read data 2</code><font style="color:rgba(0, 0, 0, 0.87);"> 作为 </font><strong><font style="color:rgba(0, 0, 0, 0.87);">ALU </font></strong><font style="color:rgba(0, 0, 0, 0.87);">的输入，与 </font><code>Read data 1</code><font style="color:rgba(0, 0, 0, 0.87);"> 进行运算</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">具体的运算操作由 </font><code>&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;ALU control&lt;/font&gt;</code><strong><font style="color:rgba(0, 0, 0, 0.87);"> </font></strong><font style="color:rgba(0, 0, 0, 0.87);">提供的信号指明（我们在 </font><strong><font style="color:rgba(0, 0, 0, 0.87);">1.3 小节</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> 讨论这个话题）。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">运算结果在 </font><strong><font style="color:rgba(0, 0, 0, 0.87);">ALU模块 </font></strong><font style="color:rgba(0, 0, 0, 0.87);">的 </font><code>ALU result</code><font style="color:rgba(0, 0, 0, 0.87);"> 中。</font></li>
</ul>
</li>
<li><font style="color:rgba(0, 0, 0, 0.87);">(3) 处 </font><strong><font style="color:rgba(0, 0, 0, 0.87);">MUX </font></strong><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">在 </font><code>MemtoReg = 0</code><font style="color:rgba(0, 0, 0, 0.87);"> 的信号作用下选择 </font><code>ALU result</code><font style="color:rgba(0, 0, 0, 0.87);"> 作为写回 Register 的值，连到 (4) 处；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">在 (5) 处 </font><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;RegWrite&lt;/font&gt; = 1</code><font style="color:rgba(0, 0, 0, 0.87);"> 信号控制下，该值写入到 </font><code>rd</code><font style="color:rgba(0, 0, 0, 0.87);"> 寄存器中。</font></li>
</ul>
</li>
</ul>
<p><font style="color:rgba(0, 0, 0, 0.87);">这就是 R 型指令的运行过程。执行完指令后 PC 会 +4，我们在 </font><strong><font style="color:rgba(0, 0, 0, 0.87);">1.4 小节</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> 讨论这一操作的实现。</font></p>
<h2 id="PTuq1">1.3 Load指令和Store指令--datapath</h2>
1. 运行过程
+ read register operands
+ calculate address using 12-bit offset
    - ld/sd指令中immediat的存放：12-bit offset，再补一个隐式0后变成immediate
    - 需要用到`Imm Gen`模块（因为指令是32位，所以这一步需要将立即数拓展到64位，64位机做的是64-bit计算）
+ load：read memory and update register
+ store：write register value to memory
2. 带有R-type/ld/sd 指令的datapath
+ ![](https://cdn.nlark.com/yuque/0/2024/png/42470693/1731484387320-e5da7337-65d1-44b8-b405-7a9b89997503.png)
+ `MemtoReg`选择写进`rd/Write data`的是`Read data（ld/sd）`或者`ALU result（R-type）`

<h2 id="mxC3m">1.4 branch #inst--datapath</h2>
> 只实现beq rs1，rs2 ，offset
>

<ol>
<li>运行过程</li>
</ol>
<ul>
<li>read register operands</li>
<li>compare operands<ul>
<li>使用ALU 减法功能，判断output是否为0（<code>Zero</code>端口）</li>
</ul>
</li>
<li>calculate target address<ul>
<li>对立即数进行<font style="color:#DF2A3F;">符号位</font>扩展，得到offset</li>
<li>shift left 1 bit（因为立即数最后一位必是0，即默认是halfword对齐）</li>
<li>add to PC</li>
</ul>
</li>
</ul>
<ol start="2">
<li>datapath</li>
</ol>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731486875379-2d014166-e3a0-450a-8400-9859849922e5.png"></li>
<li><code>Zero</code>信号接给PC，判断是选择PC+4&#x2F;target address</li>
</ul>
<h2 id="FNWRn">1.5 datapath 整合</h2>
1. 完整的datapath
+ ![](https://cdn.nlark.com/yuque/0/2024/png/42470693/1731487405360-ccd576ea-d161-4f6b-bfbe-a0b13b2cecfa.png)
+ 图中`Zero`不是指向data memory，而是给PC使用
+ `Inst[31:0]`一起作为immediate给到`Imm Gen`：因为不同指令格式，立即数的排布不一样，所以需要一起取出来；在`Imm Gen`里面根据指令类型，将对应的立即数排布好，生成出来
2. 针对UJ-type #inst（`Jal`）
+ ![](https://cdn.nlark.com/yuque/0/2024/png/42470693/1731488056823-a9bcd216-6b26-4230-a9ed-7a477a7be174.png)
+ 需要在控制PC选择时，再加一个MUX：为了单独控制
    - `beq`指令执行：去看`Zero`的结果
    - `Jal`指令执行：只需要看此时是否为jal就行



<h2 id="Ss5UC">1.6 controller</h2>
> 控制信号来自32位指令
>
> 需要控制：
>
> + 执行的操作
> + 数据流动
>

<h3 id="o79R8">1.6.1 overview  &（main）Control一级译码</h3>
1. 控制信号：7+4个
+ ![](https://cdn.nlark.com/yuque/0/2024/png/42470693/1731497892884-fbf1f123-afec-414f-b5d7-a5598e6bf69d.png)
2. 7个（1有效，0代表无效）
+ `**RegWrite**`：=0时NONE；=1时，`Write data`会被写入`Write reg/rd`
+ `ALUSrc`：ALU source；=0时选择<font style="color:rgba(0, 0, 0, 0.87);"> </font>`Read data 2/rs2`<font style="color:rgba(0, 0, 0, 0.87);"> ，=1时选择 </font>`Imm`<font style="color:rgba(0, 0, 0, 0.87);"> </font>
+ `MemRead`：=0时NONE；=1时memory对应的地址中的值被放到其输出端口`Read data`
+ `**MemWrite**`：=0时NONE；=1时memory对应的地址中的值被其输入端口`Write data`中的值代替
    - `MemRW`：memory read and write； 取值处写write/read
+ `MemtoReg`：选择写进register模块的`Write data`的值：=00时选择`ALU_result`；=01时选择`data memory`；=10时选择PC+4（`jal`指令会用到）

<p>&#x3D;11时用不到，任意赋一个值即可，不能悬空（会漏电）</p>
<ul>
<li><code>Branch/PCSrc</code>：&#x3D;0时PC选择PC+4；&#x3D;1时PC选择<strong>branch</strong> target address</li>
<li><code>jump</code>&#x3D;0时PC选择PC+4&#x2F;branch target address；&#x3D;1时PC选择<strong>jump</strong> target address</li>
</ul>
<ol start="3">
<li>举例：</li>
</ol>
<ul>
<li>sd：7个控制信号的值从上到下分别是<strong>0</strong><em>1_0_1</em><font style="color:#DF2A3F;">XX</font>_0_0</li>
<li>ld：7个控制信号的值从上到下分别是1_1_1_0_01_0_0</li>
<li><em><strong>所以只要知道指令类型（opcode），这7个信号就定下来了</strong></em></li>
<li>Main decoder 输入信号：<code>opcode前5位</code>：因为不同指令格式下，opcode的后两位一样</li>
</ul>
<ol start="4">
<li>4位：<code>ALU operation</code>：即<code>ALU control output</code></li>
</ol>
<p>共用四位（高位没有就补0）表示以下<strong>8种ALU操作</strong>：<code>add</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>sub</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>AND</code><font style="color:rgba(0, 0, 0, 0.87);"> , </font><code>OR</code><font style="color:rgba(0, 0, 0, 0.87);"> ，</font><code>&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;sllt&lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.87);">，</font><code>&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;nor&lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.87);">，</font><code>&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;srl&lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.87);">，</font><code>&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;xor&lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.87);">。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.87);">与具体的指令类型无直接联系，而与具体需要ALU做的下面8种操作有关。</font></p>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731489122153-fac4136e-7a6b-4552-89a9-e7f0169ca40b.png"></li>
</ul>
<h3 id="GFWvp">1.6.2  **ALU control** 二级译码</h3>
> 1. ALU control unit的输入信号：
> + `ALUOp`：2位，用来判断指令是ld、sd（00）/branch（01）/R-type、**addi**（10）
> + FUNC7的1位+FUNC3 = 4 bits：用来进一步判断R-type中的具体指令
> 2. ALU control unit的输出信号：
> + `ALU operation/ALU control/ALU control output`：4位，传给`ALU`，决定具体做什么操作
> 3. 可以将值设为“don't care”即X的控制信号：
> + `ALUSrc`：jal
> + `ALUOp`jal是XX
> 4. data path中只要该指令中没有用到的信号，都可以设为x
> 5. 但是control信号中与memory、regfile**写**相关的，必须设置为0（即RegWrite = 0；MemWrite = 0）
>

<ol>
<li>对指令的分类——<code>ALUOp</code></li>
</ol>
<p>易知可以分为以下三类</p>
<ul>
<li><code>ALUOp</code> &#x3D; 00：ld&#x2F;sd；F &#x3D; add</li>
<li><code>ALUOp</code> &#x3D; 01：branch；F &#x3D; subtract</li>
<li><code>ALUOp</code> &#x3D; 10：R-type；F depends on func3&#x2F;func7（opcode都一样）</li>
</ul>
<ol start="2">
<li>构造两级解码</li>
</ol>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731499137854-a93463c6-d4b2-4a1e-88a7-9f064a6be1be.png"></li>
<li><strong>Control–main decoder（first level）</strong>：只需要看opcode就可以解码出对应的7个信号，又因为不同指令类型的opcode后两位相同，所以只需要<code>opcode</code>的前五位作为输入：<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42470693/1733751112198-19ecc247-84b2-413b-a573-80101800a99a.jpeg"></li>
<li>x代表1&#x2F;0不影响–可以进行优化</li>
</ul>
</li>
<li><strong>ALU Control–ALU decoder（second level）</strong>：<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731826738539-4e6d8356-46e4-43ae-8939-abc0145cd3df.png"></li>
<li>上述表格的真值表：上面的ALU control就是<code>ALU operation</code>，即<code>ALU control output</code></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730858436685-0700246f-6265-411f-9e76-7c1c3d37312d.png"></p>
<pre><code>- &lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;其中可以发现，标为绿色的列的取值要么是 0 要么是无关的，因此它们并不影响结果&lt;/font&gt;
- &lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;所以我们只需要取出&lt;/font&gt;`&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;Inst[30,14:12]&lt;/font&gt;`&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;（上图标红部分），再加上&lt;/font&gt;**&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;Control &lt;/font&gt;**&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;单元（main decoder）给出的 &lt;/font&gt;`ALUOp`&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt; 信号，即可作为&lt;/font&gt;**&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;ALU control&lt;/font&gt;**&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;的输入；其输出信号记为4-bit 的&lt;/font&gt;`&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;ALU operation&lt;/font&gt;`
- ![](https://cdn.nlark.com/yuque/0/2024/png/42470693/1735647488751-717e7fec-4128-4b4d-8370-d61151863024.png)
</code></pre>
<h1 id="QvAV0">2、Pipeline</h1>
> 单周期CPU：
>
> + 每个时钟周期完成一条指令<font style="color:rgba(0, 0, 0, 0.87);">CPI = 1</font>
> + <font style="color:rgba(0, 0, 0, 0.87);">时钟周期的长度由耗时最长的指令（load）决定</font>
> + <font style="color:rgba(0, 0, 0, 0.87);">所以违背了设计原则：</font>**<font style="color:rgba(0, 0, 0, 0.87);">Make</font>**<font style="color:rgba(0, 0, 0, 0.87);"> </font>**<font style="color:rgba(0, 0, 0, 0.87);">common case fast（ld指令不是最常用的）</font>**
>
> 因此引入新的实现技术：流水线
>
> RISC-V指令集专门为流水线设计
>

<h2 id="r1tlf">2.1 introduction</h2>
1. 设计理念
+ 将一个指令任务拆成多个部分，并满足：每个部分时间尽量一致，且相互之间不影响（无overlap）；以实现流水线
+ 不是每个指令都需要五步，但是每一步都要经历，不需要的那一步不做事就行

<hr>
<ol start="2">
<li><font style="color:rgba(0, 0, 0, 0.87);">回到 RISC-V 中来，一个指令通常被划分为 5 个阶段：（</font>五级）</li>
</ol>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.87);">IF, Inst Fetch</font></strong><font style="color:rgba(0, 0, 0, 0.87);">，从内存中获取指令（指令长度</font><strong><font style="color:rgba(0, 0, 0, 0.87);">一样</font></strong><font style="color:rgba(0, 0, 0, 0.87);">–不同指令取址时间差不多）</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.87);">ID, Inst Decode &amp; Register Read</font></strong><font style="color:rgba(0, 0, 0, 0.87);">，读取寄存器、指令译码（二者可以同时进行，</font><strong><font style="color:rgba(0, 0, 0, 0.87);">寄存器位置是固定的–译码是都按照</font><strong><strong><font style="color:rgba(0, 0, 0, 0.87);background-color:#FBDE28;">R-type</font></strong></strong><font style="color:rgba(0, 0, 0, 0.87);">来翻译</font></strong><font style="color:rgba(0, 0, 0, 0.87);">，所以有时候得到的rd寄存器可能是立即数的一部分，比如S和SB-type在R-type的rd对应的位置，存放的是立即数）</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.87);">EX, Execute Operation or Calculate Address</font></strong><font style="color:rgba(0, 0, 0, 0.87);">，计算操作结果  和&#x2F;或  计算地址</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.87);">MEM, Memory</font></strong><font style="color:rgba(0, 0, 0, 0.87);">，内存存取（如果需要的话）</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.87);">WB, Write Back</font></strong><font style="color:rgba(0, 0, 0, 0.87);">，将结果写回寄存器（如果需要的话）</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730883750189-7210b0af-b2cf-43c5-bcab-184ff1473a48.png"></li>
</ul>
<hr>
<ol start="3">
<li>时间</li>
</ol>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">由于流水线可以并行地同时执行五个阶段的步骤，所以此时的周期只需要一个阶段的长度</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">总的来说，单周期 CPU 的时钟周期由总耗时最长的指令决定，流水线 CPU 的时钟周期由耗时最长的指令阶段（IF, ID 等）决定</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">也就是说，我们本来是在一个周期中完成一个指令，而现在是在一个周期中完成五个不同指令的不同阶段。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">当然，每个时钟周期的长度也需要足够任何一个阶段完成执行</font></li>
</ul>
<hr>
<ol start="4">
<li>进步</li>
</ol>
<ul>
<li>CPI $ \approx $ 1：平均每个时钟周期（200ps）都有一个指令完成，<strong>提高</strong>了吞吐量<strong>throughout</strong><ul>
<li><strong>近似是因为一开始流水线还没完全运行起来</strong></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730892121123-db460252-bc3d-4469-b450-4462fd5fde68.png"></li>
<li>从第5个时钟周期开始，每个周期都有一个指令完成（WB完成标志指令结束）</li>
</ul>
</li>
<li><strong>latency</strong>：time for each inst<strong>没变</strong>–每条指令都用了5个阶段</li>
<li><strong>throughput</strong>：提高</li>
<li>相比单周期：<ul>
<li>speedup due to increased throughput</li>
<li>如果all stages are balanced：即每个阶段的时间一样长，**speed up **5倍 &#x3D; 级数</li>
<li>not balanced：speed less</li>
</ul>
</li>
</ul>
<hr>
<ol start="5">
<li><font style="color:rgba(0, 0, 0, 0.87);">Hazards 竞争（</font><strong><font style="color:rgba(0, 0, 0, 0.87);">2.2&#x2F;2.3&#x2F;2.4</font></strong><font style="color:rgba(0, 0, 0, 0.87);">会详细介绍）</font></li>
</ol>
<blockquote>
<p><font style="color:rgba(0, 0, 0, 0.87);">阻止下一个指令在下一个时钟周期完成的一些情况，要等待（</font><strong><font style="color:rgba(0, 0, 0, 0.87);">bubble&#x2F;stall</font></strong><font style="color:rgba(0, 0, 0, 0.87);">）</font></p>
<p>具体分为以下三种：</p>
</blockquote>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">Structure hazards 得到较好的解决<br></font><font style="color:rgba(0, 0, 0, 0.87);">A required resource is busy.</font></li>
</ul>
<p><font style="color:rgba(0, 0, 0, 0.87);">比如指令内存和数据内存没有分开（解决：inst&#x2F;data caches）</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">Data hazard<br></font><font style="color:rgba(0, 0, 0, 0.87);">Need to wait for previous instruction to complete its data read&#x2F;write.</font></li>
</ul>
<p>比如当前指令 读取的<strong>寄存器</strong>，需要等到上一条load指令对其<strong>加载&#x2F;更新完</strong>，才能访问</p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">Control hazard<br></font><font style="color:rgba(0, 0, 0, 0.87);">Deciding on control action depends on previous instruction.</font></li>
</ul>
<hr>
<ol start="6">
<li>总结</li>
</ol>
<ul>
<li>Pipelining improves performance by increasing instruction throughput<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">Executes multiple instructions in parallel</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">Each instruction has the same latency</font></li>
</ul>
</li>
<li><font style="color:rgba(0, 0, 0, 0.87);">Subject to hazards(Structure, data, control)</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">Instruction set design affects complexity of pipeline implementation</font></li>
</ul>
<hr>
<p>下面三小节会通过解决三个竞争，来展示如何一步步设计流水线CPU的datapath和controller模块</p>
<ul>
<li><em><font style="color:rgba(0, 0, 0, 0.87);">Single-clock-cycle pipeline diagram</font></em><font style="color:rgba(0, 0, 0, 0.87);">: Shows pipeline usage in a single cycle; Highlight resources used</font><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730896659350-7a5f38a2-34cd-4baa-98b4-4d63d329e16a.png"></li>
<li>单看每条指令，只能看到其的某一个阶段</li>
<li>图中五个阶段都是不同的指令</li>
</ul>
</li>
<li><em><font style="color:rgba(0, 0, 0, 0.87);">multi-clock-cycle diagram</font></em><font style="color:rgba(0, 0, 0, 0.87);">: Graph of operation over time</font><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730896627383-6b3ed972-7615-411b-8e03-9442a6caaeb1.png"></li>
</ul>
</li>
</ul>
<hr>
<h2 id="M3MBu">2.2 <font style="color:rgba(0, 0, 0, 0.87);">Structure hazards</font></h2>
> + <font style="color:rgba(0, 0, 0, 0.87);">A required resource is busy.</font>
>
> <font style="color:rgba(0, 0, 0, 0.87);">比如，前一个指令在 </font>`ID`<font style="color:rgba(0, 0, 0, 0.87);"> 阶段的时候，会使用到其在 </font>`IF`<font style="color:rgba(0, 0, 0, 0.87);"> 阶段读出的指令的内容；但与此同时后一个指令已经运行到 </font>`IF`<font style="color:rgba(0, 0, 0, 0.87);"> 阶段并读出了新的指令，那么前一个指令就没的用了！这个现象在很多地方普遍存在，包括 Control 信号的传递</font>
>

<ol>
<li><font style="color:rgba(0, 0, 0, 0.87);">设计datapath</font></li>
</ol>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">因此我们实际上会在每两个 stage 之间用一些寄存器pipeline registers保存这些内容</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">例如 </font><code>IF/ID</code><font style="color:rgba(0, 0, 0, 0.87);"> 就是 </font><code>IF</code><font style="color:rgba(0, 0, 0, 0.87);"> 和 </font><code>ID</code><font style="color:rgba(0, 0, 0, 0.87);"> 阶段之间的一些寄存器。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">将所有之后阶段需要用到的寄存器全部一级一级传下去（不能跳传）</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730895457420-35d37488-a72b-40e9-ac29-0705d1da4c25.png"></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">注意到，有两个从右往左传东西的情况：一个是 </font><code>WB</code><font style="color:rgba(0, 0, 0, 0.87);"> 阶段写回数据，一个是 </font><code>MEM</code><font style="color:rgba(0, 0, 0, 0.87);"> 阶段判断是否发生跳转。分别关注对应增加的 datapath：</font><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">对于 </font><code>WB</code><font style="color:rgba(0, 0, 0, 0.87);"> 来说，我们写回时需要记录写到哪个 register 中，这个信息是 </font><code>ID</code><font style="color:rgba(0, 0, 0, 0.87);"> 阶段从 Instruction 中 </font><code>[11:7]</code><font style="color:rgba(0, 0, 0, 0.87);"> 的位置取出的，但是直到 </font><code>WB</code><font style="color:rgba(0, 0, 0, 0.87);"> 阶段才被用到，</font><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">因此这个信息被存到了 </font><code>ID/EX</code><font style="color:rgba(0, 0, 0, 0.87);"> ，下一个周期存到了 </font><code>EX/MEM</code><font style="color:rgba(0, 0, 0, 0.87);"> ，下一个周期存到了 </font><code>MEM/WB</code><font style="color:rgba(0, 0, 0, 0.87);"> ，然后下一个周期被使用</font></li>
</ul>
</li>
<li><del><font style="color:rgba(0, 0, 0, 0.87);">对于 </font></del><code>~~MEM~~</code><del><font style="color:rgba(0, 0, 0, 0.87);"> 来说，选择的控制信号应该是从EX&#x2F;MEM发出的（保存MEM阶段需要用到的寄存器）</font></del></li>
</ul>
</li>
<li><font style="color:rgba(0, 0, 0, 0.87);">另外，由于在流水线中 IF 和 MEM 都有可能用到内存，为了不出现结构竞争，我们将数据和指令放在不同的地方，以避免同时出现要访问内存而导致的结构竞争。</font></li>
</ul>
<ol start="2">
<li>添加controller功能</li>
</ol>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730896377430-73d458e9-624c-4c40-b502-e8eb9e1dbab8.png"></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">controller结构与单周期完全一致，只是添加了控制信号传输的功能</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">控制信号在 ID 阶段全部译出，随后通过寄存器传到后续阶段中去。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">有些信号在 WB 阶段用，有些在 M 阶段用，有些在 EX使用之后就</font><strong><font style="color:rgba(0, 0, 0, 0.87);">不再需要把信号传递下</font></strong><font style="color:rgba(0, 0, 0, 0.87);">去。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">ps：除了IF阶段的PC指令选择是否跳转，需要控制信号</font><code>&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;PCSrc&lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.87);">；IF和ID阶段都不需要用到控制信号</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">另外，由于在流水线中 </font><code>&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;IF &lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.87);">和</font><code>&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt; MEM &lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.87);">都有可能用到内存，为了不出现结构竞争，我们将数据和指令放在不同的地方，以避免同时出现要访问内存而导致的结构竞争</font></li>
</ul>
<h2 id="HPwY0">2.3 <font style="color:rgba(0, 0, 0, 0.87);">Data hazards</font></h2>
> 指令的所需的数据依赖上一条指令的目标寄存器
>

<h3 id="BNDS4">2.3.1 解决问题的方法</h3>
1. 问题
+ ![](https://cdn.nlark.com/yuque/0/2024/png/42470693/1730897104332-36c72bf9-6b79-4680-af4e-8c3e1bbdf970.png)
+ <font style="color:rgba(0, 0, 0, 0.87);">用</font>_<font style="color:rgba(0, 0, 0, 0.87);">multi-clock-cycle diagram</font>_<font style="color:rgba(0, 0, 0, 0.87);">查看一下，上述指令序列，各指令各 stage 的执行时间：</font>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730897148986-b31558d3-51a4-4c65-8aa0-6ad58da6590a.png"></p>
<blockquote>
<p><font style="color:rgba(0, 0, 0, 0.54);">我们简单介绍一下这张图。最上面是横轴，也就是时间轴，CC 代表 Clock Cycle；下面的 10, -20 这种数据是 </font><code>x2</code><font style="color:rgba(0, 0, 0, 0.54);"> 寄存器的值；接下来的每一行都是一个语句的执行过程， </font><code>IM</code><font style="color:rgba(0, 0, 0, 0.54);"> 就是 inst mem，对应 </font><code>IF</code><font style="color:rgba(0, 0, 0, 0.54);"> stage； </font><code>Reg</code><font style="color:rgba(0, 0, 0, 0.54);"> 就是 reg file，对应 </font><code>ID</code><font style="color:rgba(0, 0, 0, 0.54);"> stage；长得像 ALU 的就是 ALU，对应 </font><code>EX</code><font style="color:rgba(0, 0, 0, 0.54);"> stage； </font><code>DM</code><font style="color:rgba(0, 0, 0, 0.54);"> 就是 data mem，对应 </font><code>MEM</code><font style="color:rgba(0, 0, 0, 0.54);"> stage；最后面的 </font><code>Reg</code><font style="color:rgba(0, 0, 0, 0.54);"> 也是 reg file，对应 </font><code>WB</code><font style="color:rgba(0, 0, 0, 0.54);"> stage。每个 stage 占用一个时钟周期。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.54);">图中深色（灰色、蓝色）的部分就是对应指令会使用到的组件，其中 mem 和 reg file 用左半边为深色时表示 </font><strong><font style="color:rgba(0, 0, 0, 0.54);">写入</font></strong><font style="color:rgba(0, 0, 0, 0.54);">，右半边为深色时表示 </font><strong><font style="color:rgba(0, 0, 0, 0.54);">读取</font></strong><font style="color:rgba(0, 0, 0, 0.54);">。</font></p>
</blockquote>
<ul>
<li>这种<font style="color:rgba(0, 0, 0, 0.87);">由于指令所需的数据依赖于前面一条尚未完成的指令，导致指令不能在预期的时钟周期内执行的情况，我们称之为 </font><strong><font style="color:rgba(0, 0, 0, 0.87);">data hazard</font></strong><font style="color:rgba(0, 0, 0, 0.87);">。</font></li>
</ul>
<ol start="2">
<li>设计datapath来解决hazard</li>
</ol>
<ul>
<li>注意到在上图中，虽然第一条指令<font style="color:rgba(0, 0, 0, 0.87);"> </font><code>sub x2, x1, x3</code><font style="color:rgba(0, 0, 0, 0.87);"> 在第 5 个时钟周期的 </font><code>WB</code><font style="color:rgba(0, 0, 0, 0.87);"> 阶段才将结果写回，但是在第 3 个时钟周期的 </font><code>EX</code><font style="color:rgba(0, 0, 0, 0.87);"> 阶段其实就算出来了！所以我们可以增加额外的硬件结构，使得 ALU 的输入不仅可以来源于寄存器中读出来的、放在 </font><code>ID/EX</code><font style="color:rgba(0, 0, 0, 0.87);"> 中的值，还可以来源于 </font><code>EX/MEM</code><font style="color:rgba(0, 0, 0, 0.87);"> 中或者 </font><code>MEM/WB</code><font style="color:rgba(0, 0, 0, 0.87);"> 中的值，它们分别对应前一条和再前一条指令的 ALU 的计算结果。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">添加的硬件结构称为</font><em><strong><font style="color:rgba(0, 0, 0, 0.87);background-color:#FBDE28;">Forwarding&#x2F;bypass</font></strong></em><font style="color:rgba(0, 0, 0, 0.87);">（下图蓝线部分）</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730897507458-c43526d1-45e3-47f2-8e48-74e158356231.png"></li>
<li>第四条开始已无数据竞争了</li>
</ul>
<ol start="3">
<li>进一步消除stall——reorder code，对指令进行等价换序_**<font style="color:rgba(0, 0, 0, 0.87);"> </font><strong>__</strong><font style="color:rgba(0, 0, 0, 0.87);background-color:#FBDE28;">code scheduling</font>**_<img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730897882150-735aef5c-5415-417f-8d04-d417359bad5a.png"></li>
</ol>
<ul>
<li>我们需要根据上图，<font style="background-color:#FBDE28;">计算汇编代码需要多少个时钟周期（考试要求）</font><ul>
<li>先不考虑hazard：除了第一条指令需要5个周期，后面每条所需cycles &#x3D; 1</li>
<li>接着加入hazard的影响：找到依赖关系（即存在hazard），加上需要bubble周期（因为<strong>load指令要到</strong><code>**MEM/WB**</code><strong>才能读出rd</strong>；bypass之后还是需要插入一个nop</li>
<li>或者看看能否改变顺序使得依赖关系消除</li>
<li>方法：画多周期流水线图解决</li>
</ul>
</li>
</ul>
<h3 id="E8QPv">2.3.2 实现解决方法_**<font style="color:rgba(0, 0, 0, 0.87);background-color:#FBDE28;">Forwarding/bypass——</font>**__**<font style="color:rgba(0, 0, 0, 0.87);">设计datapath</font>**_</h3>
1. 如何判断是否出现data hazard，需要满足下面三个条件
+ 下一指令的源寄存器与上一指令的目标寄存器一致
+ regwrite = 1（若其为0，代表实际指令中其实没有rd寄存器存在，只是刚好解码时该指令在R-type rd寄存器对应的位置，的立即数等于下一指令的rs1/rs2的值）
+ rd$ \ne $0：x0不用bypass（因为始终是0不会改变，不需要等上一条计算完才用它）
+ **<font style="background-color:#FBDE28;">总结</font>**：
    - 条件一：下面4 cases满足其中1个即可
        * `EX/MEM.RegisterRd = ID/EX.RegisterRs1`<font style="color:rgba(0, 0, 0, 0.87);">  
</font><font style="color:rgba(0, 0, 0, 0.87);">在第四个时钟周期</font><font style="color:#DF2A3F;">开始时</font><font style="color:rgba(0, 0, 0, 0.87);">把 上一指令的EX/MEM 的寄存器值送到 下一指令EX阶段的ALU.</font>
        * `MEM/WB.RegisterRd = ID/EX.RegisterRs1`

<p><font style="color:rgba(0, 0, 0, 0.87);">在第五个时钟周期</font><font style="color:#DF2A3F;">开始时</font><font style="color:rgba(0, 0, 0, 0.87);">把 上一指令的MEM&#x2F;WB 的寄存器值送到 下一指令EX阶段的		ALU.</font></p>
<pre><code>    * `EX/MEM.RegisterRd = ID/EX.RegisterRs2`
    * `MEM/WB.RegisterRd = ID/EX.RegisterRs2`
- 条件二：`EX/MEM.RegWrite, MEM/WB.RegWrite`&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt; 不为 0&lt;/font&gt;
- &lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;条件三：&lt;/font&gt;`EX/MEM.RegisterRd, MEM/WB.RegisterRd`不为0
</code></pre>
<ol start="2">
<li>出现了如何解决</li>
</ol>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730898847671-399d9089-3b7f-459b-93cc-7c6b2aa4c1d1.png"></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730898990310-6e1627ab-5eed-4d36-a61e-1d16e07e3618.png"></li>
<li>A&#x3D;00是表示不依赖上一条指令；A &#x3D; 10&#x2F;01表示分别从<code>EX/MEM</code>、<code>MEM/WB</code>进行forward</li>
<li>遇到是一条指令load这种情况，load<font style="color:rgba(0, 0, 0, 0.87);">的数据正常要到 WB才有；得等两个stall，通过forward可以提前到MEM阶段，等一个stall；要是想完全消除stall，需要用到</font><strong><font style="color:rgba(0, 0, 0, 0.87);">2.3.1</font></strong><font style="color:rgba(0, 0, 0, 0.87);">中介绍的</font><em><strong><font style="color:rgba(0, 0, 0, 0.87);"> </font></strong>__<strong><font style="color:rgba(0, 0, 0, 0.87);background-color:#FBDE28;">code scheduling</font></strong></em></li>
</ul>
<ol start="3">
<li>需要解决的特殊情况——<font style="color:rgba(0, 0, 0, 0.87);">Double Data Hazard</font></li>
</ol>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1730899444434-e05a8089-9ae8-4c01-95e2-6ef676eb12ca.png"></li>
<li>上述第三条指令的x1的值：既可以从第二条指令的EX&#x2F;MEM处bypass，也可以从第一条指令的MEM&#x2F;WB处bypass；很明显只有前者是正确的。解决方法：</li>
<li>只需要forward时添加一个条件：判断是MEM hazard时，<strong><font style="color:rgba(0, 0, 0, 0.87);">只有在 EX&#x2F;MEM 的条件不成立时</font></strong><font style="color:rgba(0, 0, 0, 0.87);">，才能查看 MEM&#x2F;WB 的条件。</font><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731419365170-9ed66d02-aa22-4b19-b7ec-c687a611a6c6.png"></li>
</ul>
</li>
</ul>
<h3 id="QtaGN">2.3.3 datapath with Forwarding（将controller加上）</h3>
![](https://cdn.nlark.com/yuque/0/2024/png/42470693/1730899772475-203011e3-5a9b-4b9f-8838-e3ad8c8533db.png)

<h3 id="mp5a0">2.3.4 <font style="color:rgba(0, 0, 0, 0.87);">遇到 load 指令不得不 stall</font></h3>
> <font style="color:rgba(0, 0, 0, 0.87);">刚刚可以不用stall是因为 EX 和 ID 就差了一轮，但是 load 的数据要到 MEM 才有，所以如果下一条指令要用，上一条也拿不出来，只能要 stall 等才行</font>
>

<ol>
<li>load-use hazard detection</li>
</ol>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">在 ID 阶段可以判定 hazard：</font><code>if (ID/EX.MemRead &amp;&amp; IDEX.Rd == IF/ID.Rs&lt;font style=&quot;color:#DF2A3F;&quot;&gt;X&lt;/font&gt;) Hazard();</code> X &#x3D; 1&#x2F;2</li>
<li>if detected, stall and insert bubble</li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731419796622-9f8e7ff3-148e-47d0-ab73-e44efce39486.png"></li>
</ul>
<ol start="2">
<li><font style="color:rgba(0, 0, 0, 0.87);">如何 stall 呢</font></li>
</ol>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">让当前指令不要产生效果 (清空 </font><code>RegWrite</code><font style="color:rgba(0, 0, 0, 0.87);"> 和 </font><code>MemWrite</code><font style="color:rgba(0, 0, 0, 0.87);"> )，并让</font><code>&lt;font style=&quot;color:rgba(0, 0, 0, 0.87);&quot;&gt;EX/MEM/WB&lt;/font&gt;</code><font style="color:rgba(0, 0, 0, 0.87);">do nop(no-operation)</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">让后面的语句不要受到影响 (保留 </font><code>PC</code><font style="color:rgba(0, 0, 0, 0.87);"> 和 </font><code>IF/ID</code><font style="color:rgba(0, 0, 0, 0.87);"> 一周期不改)</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">为此重新设计datapath的结构——datapath with hazard detection</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731420011622-7410418b-8ca5-4210-83b5-94fd9e4d57f8.png"></li>
<li>解释<code>Hazard detection unit</code>：三条黑色的输入线，分别是从当前指令的<code>IF/ID</code>阶段读出的rs1&#x2F;rs2，以及从上一指令的<code>ID/EX</code>读出的rd；蓝色的输入是判断上一条指令是否为load（只有load的read操作控制信号为1）；三条蓝色的输出线都是让对应的阶段进行bubble<font style="color:rgba(0, 0, 0, 0.87);"> (保留 </font><code>PC</code><font style="color:rgba(0, 0, 0, 0.87);"> 和 </font><code>IF/ID</code><font style="color:rgba(0, 0, 0, 0.87);"> 一周期不改)</font></li>
</ul>
<h2 id="WugLZ">2.4 <font style="color:rgba(0, 0, 0, 0.87);">Control/Branch hazards</font></h2>
> 比如跳转指令会改变下一指令的地址，但是需要等到**EX(但我们假设是MEM)**阶段后才能知道；
>
> 分支判断可以提前到**ID**阶段
>
> 所以不知道下一次该执行什么指令
>

<ol>
<li>方法1：提前检测branch inst</li>
</ol>
<ul>
<li>branch指令要到<code>**&lt;font style=&quot;color:#DF2A3F;&quot;&gt;MEM/WB&lt;/font&gt;**</code>阶段才会给出是否跳转的结果，所以中间需要<strong>顺序地</strong>再做3条指令，要是最后是跳转，这三条指令都白做了<ul>
<li>若是<code>MEM/WB</code>给出判断结果，则中间需要加入3个NOP</li>
</ul>
</li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731420828968-47404764-1c61-4823-a335-f528e3808284.png"></li>
<li>因为branch inst的rs1&#x2F;rs2、立即数在<code>ID</code>阶段就解码出来了，所以添加<strong>下面的</strong>硬件，在<code>ID</code>阶段就可以给出判断结果<ul>
<li>register comparator：比较rs1&#x2F;rs2是否相等</li>
<li>target address adder：提前将要跳转的地址加好（立即数）</li>
</ul>
</li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731422908269-26e88199-65dc-4ba9-ae93-7fee9b8320fb.png"></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">这样我们只可能多余一条指令，插入 bubble 即可</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">但是在流水线的级数更多时，需要插入的bubble会增多——使用</font>dynamic branch prediction解决</li>
</ul>
<ol start="2">
<li>方法二：prediction</li>
</ol>
<ul>
<li>static branch prediction<ul>
<li>按照典型的分支属性进行预测</li>
<li>比如针对loop和if语句，总是预测<strong>backward</strong> branches taken（总是要进入下一次循环、if执行的概率比else的部分大）、预测forward branches not taken</li>
</ul>
</li>
<li>dynamic branch prediction<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">Branch prediction buffer (aka branch history table)<br></font><font style="color:rgba(0, 0, 0, 0.87);">记录前几次是否命中</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">Indexed by recent branch instruction addresses</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">Stores outcome (taken&#x2F;not taken)</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">To execute a branch</font><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">Check table, expect the </font><strong><font style="color:rgba(0, 0, 0, 0.87);">same</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> outcome</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">Start fetching from fall-through or target</font></li>
<li><font style="color:#DF2A3F;">If wrong, flush pipeline and </font><strong><font style="color:#DF2A3F;">flip</font></strong><font style="color:#DF2A3F;"> prediction（1-bit predictor）</font></li>
</ul>
</li>
<li><font style="color:rgba(0, 0, 0, 0.87);">1-bit predictor存在的问题：对于双层循环，当内层循环要结束时会错两次</font><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">Mispredict as taken on last iteration of inner loop</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">Then mispredict as not taken on first iteration of inner loop next time around</font></li>
</ul>
</li>
<li>解决：<font style="color:rgba(0, 0, 0, 0.87);">修改预测方式：只有连续错误两次才会修改我们的预测。即 2-Bit Predictor</font><ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731423684109-234c91a2-5d55-4edc-a929-22df173ee418.png"></li>
</ul>
</li>
</ul>
</li>
<li><font style="color:rgba(0, 0, 0, 0.87);">Calculating the Branch Target</font><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">即使 branch 命中了，我们也有一个时钟的 bubble 来等待地址计算完成。<br></font><font style="color:rgba(0, 0, 0, 0.87);">但 branch 要跳转的地址其实是可以存下来的（每次循环去的地方是一样的）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">Branch target buffer</font><ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.87);">Cache缓存</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> of target addresses（只储存最近常用的地址）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">Indexed by PC when instruction fetched</li>
</ul>
</li>
</ul>
</li>
</ul>
<p></font><font style="color:rgba(0, 0, 0, 0.87);">If </font><strong><font style="color:rgba(0, 0, 0, 0.87);">hit（当要去的地方的地址在缓存中，称为命中）</font></strong><font style="color:rgba(0, 0, 0, 0.87);"> and instruction is branch predicted taken, can fetch target immediately</font></p>
<h2 id="DHu0Z">2.5 <font style="color:rgba(0, 0, 0, 0.87);">Instruction-Level Parallelism (ILP)</font></h2>
1. 概念
+ <font style="color:rgba(0, 0, 0, 0.87);">Pipelining: executing multiple instructions in parallel</font>  
<font style="color:rgba(0, 0, 0, 0.87);">指令级并行</font>
+ <font style="color:rgba(0, 0, 0, 0.87);">To increase ILP提高并行的指令</font>
    - <font style="color:rgba(0, 0, 0, 0.87);">Deeper pipeline  
</font><font style="color:rgba(0, 0, 0, 0.87);">提高级数/深度，一条流水线可以并行更多的指令，让每一级流水线做更少的事情，这样也可以提高工作频率。  
</font><font style="color:rgba(0, 0, 0, 0.87);">但流水线不能无限细分，因为流水线寄存器也会带来开销。</font>
    - **<font style="color:rgba(0, 0, 0, 0.87);">Multiple issue</font>**<font style="color:rgba(0, 0, 0, 0.87);">  
</font><font style="color:rgba(0, 0, 0, 0.87);">多发射  
</font><font style="color:rgba(0, 0, 0, 0.87);">这样可以做到 CPI < 1. 使用 </font>**<font style="color:rgba(0, 0, 0, 0.87);">Instructions Per Cycle (IPC)</font>**

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731424465577-79600989-5c8a-4e90-8596-ed676d7fe8bd.png"></p>
<p>但是指令之间的依赖关系会降低IPC</p>
<ol start="2">
<li><strong><font style="color:rgba(0, 0, 0, 0.87);">Multiple issue</font></strong></li>
</ol>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">Static multiple issue——包括dual-issue 双发<br></font><font style="color:rgba(0, 0, 0, 0.87);">编译器把能够同时放到流水线的指令排好<br></font><font style="color:rgba(0, 0, 0, 0.87);">编译器要能检测，避免竞争</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">Dynamic multiple issue<br></font><font style="color:rgba(0, 0, 0, 0.87);">CPU 自己决定执行那些指令，编译器会帮忙重排指令，但还是由 CPU 解决竞争（在放指令之前要判断是否会产生hazards）</font></li>
</ul>
<ol start="3">
<li><font style="color:rgba(0, 0, 0, 0.87);">Static multiple issue</font></li>
</ol>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">将不同的指令分到一组（issue packets），可以在同一个周期发射</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">所以packet间不能有依赖关系；如果产生了，使用nop（no-operation）</font><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">常用的无依赖packets包含：</font><ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">一个 ALU&#x2F;branch——都不用访问内存；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">一个 load&#x2F;store——需要访问内存</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731425133804-ec14f805-5e1a-4408-b033-0ad36e7f519d.png"></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">这样两条并行的流水线，可以在原来一条流水线的结构中加</font><strong><font style="color:rgba(0, 0, 0, 0.87);">部分结构</font></strong><font style="color:rgba(0, 0, 0, 0.87);">，就能同时实现两条指令一起发射了：增加register、ALU（只需要会算加法——计算ld&#x2F;sd地址）</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731463738111-78eb2fde-058b-4012-a2de-f34d13fb1496.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li>dual issue hazard</li>
</ol>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731425290031-aa1ba196-1bc7-4f8c-a8ac-6240c66dc80f.png"></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">因为存在竞争关系，所以这两条不能同时发出</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">解决方法1：</font></li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731425322337-07cf057a-c8c0-4875-b65f-a34386884c29.png"><ul>
<li>添加nop</li>
</ul>
</li>
<li>解决方法 2：loop unrolling：循环20次每次改一个值——循环5次每次改4个值</li>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1731464218820-74f95d5a-e5dc-48d1-932b-fbdd039b31f8.png"><ul>
<li>IPC &#x3D; 14&#x2F;8 &#x3D; 1.75；但是寄存器和代码开销增大</li>
</ul>
</li>
</ul>
<ol start="5">
<li><font style="color:rgba(0, 0, 0, 0.87);">Dynamic multiple issue——方法：dynamic pipeline scheduling</font></li>
</ol>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.87);">解决结果：运行指令乱序进行（结果放进reservation station–buffer缓冲区，并进行rename），避免stall</font></li>
<li><font style="color:rgba(0, 0, 0, 0.87);">但是commit result（将指令运行结果写进寄存器&#x2F;memory）是顺序执行</font></li>
</ul>
<h1 id="Eu4ub">3、Interrupts & Exceptions </h1>
> 正常指令程序时，有事情突然来打断：
>
> + 可预测的：control #inst（beq/bne/jal…）
> + 不可预测的：硬件突然触发的call #inst
>     - exception异常：来自内部CPU（overflow/**undefined #inst）**
>     - interruption中断：来自CPU外部（**input/output**）
>     - 广义上都叫做<font style="color:#DF2A3F;">exception异常</font>
>

<h2 id="KQUdm">3.1</h2>
1. 如何处理异常
+ processor：执行预先设计好的处理程序**handler**，并存入memory中
+ 如何跳转到对应的处理程序：
    - 需要了解异常的原因：将进入异常时的指令地址，存入EPC
    - 哪条指令造成了异常（记录地址，处理完异常后可能需要返回正常程序）：存入SCAUSE
2. **<font style="background-color:#FBDE28;">handler异常处理程序</font>**
+ 固定地址/查询direct模式：所有的异常都先跳到**固定的地址**，然后查询SCAUSE，再决定要去的处理程序的地址
+ 向量模式vectored：将异常的种类预先定义好，每个不同的异常都分配一个**不同的**地址；该地址存一条jal指令，然后根据该指令跳到对应的处理程序
+ 异常只可以使用查询，中断还能用向量模式
3. mode
+ RISC-V 有三种模式：M/S/U-mode
+ 所有的硬件必须提供M-mode：解释和处理异常
+ 每种模式对应一个拓展指令集

<h2 id="cLzoZ">3.2 M-mode</h2>
> 特权指令CSR：
>
> + 对CSR寄存器操作的指令
> + MRET：从异常回去：mepc <= PC
> + ecall
> + breakpoint：ebreak
>
> 立即数0扩展
>

<ol>
<li>interrupt register &#x2F;CSR register均由硬件自动完成</li>
</ol>
<ul>
<li>mtvec：决定handler的模式<ul>
<li>0查询</li>
<li>1向量模式：第二次跳转的地址 &#x3D; BASE + 4*exception code</li>
</ul>
</li>
<li>mstatus：存放机器模式状态</li>
<li><strong><font style="background-color:#FBDE28;">mepc</font></strong>：用来存放异常<strong>发生时</strong>的地址<ul>
<li>exception（狭义）：mepc&lt;–PC；处理完异常之后要回来</li>
<li>interrupted：mepc&lt;–PC+4</li>
</ul>
</li>
<li><strong><font style="background-color:#FBDE28;">mcause</font></strong>：<ul>
<li>存放异常的原因，异常编号放入exception code</li>
<li>异常类型：<ul>
<li>INT code：1：interrupt；0：exception</li>
</ul>
</li>
<li>同时出现多种问题时，按照以下优先级：external</li>
</ul>
</li>
</ul>
<ol start="2">
<li>进入异常</li>
</ol>
<ul>
<li><img src="https://cdn.nlark.com/yuque/0/2024/png/42470693/1733185308947-001908ec-7684-43ba-aac0-e6b8e8eecdf0.png"></li>
</ul>
<ol start="3">
<li>从异常服务程序中退出</li>
</ol>
<ul>
<li>RISCV中定义了一组退出指令</li>
<li><em><strong>返回主程序</strong></em>：从mepc中存入的pc地址开始执行</li>
</ul>
<ol start="4">
<li><font style="background-color:#FBDE28;">exception in pipeline</font></li>
</ol>
<ul>
<li>另一种类型的 control hazard</li>
<li>流水线中某条指令在EX阶段执行错误<ul>
<li>阻止rd寄存器的值被更新</li>
<li>完成previous inst</li>
<li>flush当前和其之后的指令：do no operation</li>
<li>更新epc和cause 寄存器</li>
<li>跳到handler处理异常</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" rel="tag"># 计算机组成</a>
              <a href="/tags/processor/" rel="tag"># processor</a>
          </div>

        

    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
